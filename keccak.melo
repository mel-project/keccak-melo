type Bit = {0..1}
type Byte = {0..7}
type U8 = {0..255}
type U64 = {0..18446744073709551615}
type LaneVec = [U8; 8] # a lane as a vector of U8s
type LaneNat = U64 # a lane as a 64-bit Nat
type Sheet = [LaneNat; 5]
type StateLanes = [Sheet; 5]
type State = [U8; 200]


# ROtate Left 64: rotates 64-bit Nat, n, b bits to the left
def rol64(n: Nat, b: Nat) =
    (n << (b % 64) | n >> (64 - (b % 64))) & 18446744073709551615

# Loads a byte vector of length 8 into a 64-bit Nat
def load64(lane_vec: LaneVec) =
    let lane_nat = 0 :: Nat in
    let ctr = 0 :: Nat in
    loop 8 do
        lane_nat <- lane_nat + (vref(lane_vec, ctr) << (ctr * 8));
        ctr <- ctr + 1
    return lane_nat

# Stores a 64-bit Nat into a byte vector of length 8
def store64(lane_nat: LaneNat) =
    unsafe let lane_vec = [] :! [Nat; 8] in
    let ctr = 0 :: Nat in
    loop 8 do
        lane_vec <- (lane_vec ++ [(lane_nat >> (ctr * 8)) % 256]) :! [Nat; 8];
        ctr <- ctr + 1
    return lane_vec

# Converts State type to StateLanes type
def to_lanes(state: State) =
    unsafe let accum = [] :! StateLanes in
    let accum_inner = [] :! Sheet in
    let x = 0 :: {0..4} in
    let y = 0 :: {0..4} in
    loop 5 do
        accum_inner <- [] :! Sheet;
        accum_inner <- loop 5 do
            accum_inner <- (accum_inner ++ [load64(state[8 * (x + 5 * y)..8 * (x + 5 * y) + 8])]) :! Sheet;
            y <- (y + 1) :! {0..4}
        return accum_inner;
        accum <- (accum ++ [accum_inner]) :! StateLanes;
        x <- (x + 1) :! {0..4};
    return accum

# Returns the C sheet which is necessary for computing the D sheet
def c(lanes: StateLanes) =
    unsafe let c = [] :! Sheet in
    let x = 0 :: {0..4} in
    loop 5 do
        c <- (c ++ [for sheet in lanes[x] fold accum = 0 :: Nat with accum ^ sheet]) :! Sheet;
        x <- (x + 1) :! {0..4}
    return c

# Returns the D sheet which is necessary for computing the θ step of the permutation
def d(c: Sheet) =
    unsafe let d = [] :! Sheet in
    let x = 0 :: Nat in
    loop 5 do
        d <- (d ++ [vref(c, (x + 4) % 5) ^ rol64(vref(c, (x + 1) % 5), 1)]) :! Sheet;
        x <- x + 1
    return d

# θ step of permutation
def theta(lanes: StateLanes) =
    unsafe let c = c(lanes) in
    let d = d(c) in
    let new_lanes = [] :! StateLanes in
    let sheet = [] :! Sheet in
    let x = 0 :: {0..4} in
    let y = 0 :: {0..4} in
    loop 5 do
        new_lanes <- (new_lanes ++ loop 5 do
            sheet <- (sheet ++ [(lanes[x][y] ^ d[x])]) :! Sheet;
            y <- (y + 1) :! {0..4}
        return [sheet]) :! StateLanes;
        x <- (x + 1) :! {0..4}
    return new_lanes

# ρ and π steps of permutation
def rho_and_pi(lanes: StateLanes) =
    unsafe let x = 1 :: {0..4} in
    let y = 0 :: {0..4} in
    let temp_x = 0 :: {0..4} in
    let t = 0 :: {0..24} in
    let curr_lane = lanes[x][y] in
    let temp_lane = 0 :! LaneNat in
    loop 24 do
        temp_x <- x;
        x <- y;
        y <- ((2 * temp_x + 3 * y) % 5) :! {0..4};
        temp_lane <- curr_lane;
        curr_lane <- lanes[x][y];
        lanes <- lanes[x => lanes[x][y => rol64(temp_lane, (t + 1) * (t + 2) / 2) :! LaneNat]];
        t <- (t + 1) :! {0..23}
    return lanes

# Returns the T sheet which is necessary for computing the χ step of the permutation
def t(lanes: StateLanes, y: {0..4}) =
    [sheet[y] for sheet in lanes]

# χ step of permutation
def chi(lanes: StateLanes) =
    unsafe let y = 0 :: {0..4} in
    let x = 0 :: {0..4} in
    let t = [] :! Sheet in
    loop 5 do
        t <- t(lanes, y);
        lanes <- loop 5 do
            lanes <- lanes[x => lanes[x][y => (t[x] ^ ((~vref(t, (x + 1) % 5)) & vref(t, (x + 2) % 5))) :! LaneNat]];
            x <- (x + 1) :! {0..4}
        return lanes;
        y <- (y + 1) :! {0..4}
    return lanes

# ι step of permutation
def iota(lanes: StateLanes, r: U8) =
    unsafe let j = 0 :: Nat in
    loop 7 do
        r <- (((r << 1) ^ ((r >> 7) * 113)) % 256) :! U8;
        lanes <- if r & 2 then lanes[0 => lanes[0][0 => (lanes[0][0] ^ (1 << ((1 << j) - 1))) :! LaneNat]] else lanes;
        j <- j + 1
    return lanes

# Computes the next R given the current R
def next_r(r: U8) =
    unsafe loop 7 do
        r <- (((r << 1) ^ ((r >> 7) * 113)) % 256) :! U8
    return r

# Keccak-f1600 permutation on lanes
def keccakf1600_on_lanes(lanes: StateLanes) =
    unsafe let r = 1 :: U8 in
    loop 24 do
        lanes <- iota(chi(rho_and_pi(theta(lanes))), r);
        r <- next_r(r)
    return lanes

# Keccak-f1600 permutation on state
def keccakf1600(state: State) =
    unsafe let lanes = keccakf1600_on_lanes(to_lanes(state)) in
    let x = 0 :: {0..4} in
    let y = 0 :: {0..4} in
    let b = 0 :: Byte in
    loop 5 do
        state <- loop 5 do
            state <- loop 8 do
                state <- state[8 * (x + 5 * y) + b => vref(store64(lanes[x][y]), b) :! U8];
                b <- (b + 1) :! Byte
            return state;
            y <- (y + 1) :! {0..4}
        return state;
        x <- (x + 1) :! {0..4}
    return state

---

let s = [
    255, 255, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
] in keccakf1600(s)