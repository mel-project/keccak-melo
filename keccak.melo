type Bit = {0..1}
type Byte = {0..7}
type U8 = {0..255}
type U64 = {0..18446744073709551615}
type LaneVec = [U8; 8] # a lane as a vector of U8s
type LaneNat = U64 # a lane as a 64-bit Nat
type Sheet = [LaneNat; 5]
type StateLanes = [Sheet; 5]
type State = [U8; 200]

# ROtate Left 64: rotates 64-bit Nat, n, b bits to the left
def rol64(n: Nat, b: Nat) =
    (n << (b % 64) | n >> (64 - (b % 64))) & 18446744073709551615

# Loads a byte vector of length 8 into a 64-bit Nat
def load64(lane_vec: LaneVec) =
    for byte in enumerate(lane_vec) fold lane_nat = 0 :: Nat with lane_nat + (byte[1] << (byte[0] * 8))

# Stores a 64-bit Nat into a byte vector of length 8
def store64(lane_nat: LaneNat) =
    for i in range(8) fold lane_vec = [] :: [Nat;] with lane_vec ++ [(lane_nat >> (i * 8)) % 256] :: [Nat;]

# Converts State type to StateLanes type
def to_lanes(state: State) =
    unsafe let accum = [] :! StateLanes in
    let accum_inner = [] :! Sheet in
    let x = 0 :: {0..4} in
    let y = 0 :: {0..4} in
    loop 5 do
        accum_inner <- [] :! Sheet;
        accum_inner <- loop 5 do
            accum_inner <- (accum_inner ++ [load64(state[8 * (x + 5 * y)..8 * (x + 5 * y) + 8])]) :! Sheet;
            y <- (y + 1) :! {0..4}
        return accum_inner;
        accum <- (accum ++ [accum_inner]) :! StateLanes;
        x <- (x + 1) :! {0..4};
    return accum

# Returns the C sheet which is necessary for computing the D sheet
def c(lanes: StateLanes) =
        unsafe for x in range(5) fold c = [] :! Sheet with (c ++ [for sheet in lanes[x :! {0..4}] fold accum = 0 :: LaneNat with (accum ^ sheet) :! LaneNat]) :! Sheet

# Returns the D sheet which is necessary for computing the θ step of the permutation
def d(c: Sheet) =
        unsafe for x in range(5) fold d = [] :! Sheet with (d ++ [vref(c, (x + 4) % 5) ^ rol64(vref(c, (x + 1) % 5), 1)]) :! Sheet

# θ step of permutation
def theta(lanes: StateLanes) =
    unsafe let c = c(lanes) in
    let d = d(c) in
    let new_lanes = [] :! StateLanes in
    let sheet = [] :! Sheet in
    let x = 0 :: {0..4} in
    let y = 0 :: {0..4} in
    loop 5 do
        new_lanes <- (new_lanes ++ loop 5 do
            sheet <- (sheet ++ [(lanes[x][y] ^ d[x])]) :! Sheet;
            y <- (y + 1) :! {0..4}
        return [sheet]) :! StateLanes;
        x <- (x + 1) :! {0..4}
    return new_lanes

# ρ and π steps of permutation
def rho_and_pi(lanes: StateLanes) =
    unsafe let x = 1 :: {0..4} in
    let y = 0 :: {0..4} in
    let temp_x = 0 :: {0..4} in
    let t = 0 :: {0..24} in
    let curr_lane = lanes[x][y] in
    let temp_lane = 0 :! LaneNat in
    loop 24 do
        temp_x <- x;
        x <- y;
        y <- ((2 * temp_x + 3 * y) % 5) :! {0..4};
        temp_lane <- curr_lane;
        curr_lane <- lanes[x][y];
        lanes <- lanes[x => lanes[x][y => rol64(temp_lane, (t + 1) * (t + 2) / 2) :! LaneNat]];
        t <- (t + 1) :! {0..23}
    return lanes

# Returns the T sheet which is necessary for computing the χ step of the permutation
def t(lanes: StateLanes, y: {0..4}) =
    [sheet[y] for sheet in lanes]

# χ step of permutation
def chi(lanes: StateLanes) =
    unsafe let y = 0 :: {0..4} in
    let x = 0 :: {0..4} in
    let t = [] :! Sheet in
    loop 5 do
        t <- t(lanes, y);
        lanes <- loop 5 do
            lanes <- lanes[x => lanes[x][y => (t[x] ^ ((~vref(t, (x + 1) % 5)) & vref(t, (x + 2) % 5))) :! LaneNat]];
            x <- (x + 1) :! {0..4}
        return lanes;
        y <- (y + 1) :! {0..4}
    return lanes

# ι step of permutation
def iota(lanes: StateLanes, r: U8) =
    unsafe let j = 0 :: Nat in
    loop 7 do
        r <- (((r << 1) ^ ((r >> 7) * 113)) % 256) :! U8;
        lanes <- if r & 2 then lanes[0 => lanes[0][0 => (lanes[0][0] ^ (1 << ((1 << j) - 1))) :! LaneNat]] else lanes;
        j <- j + 1
    return [lanes] ++ [r]

# Keccak-f1600 permutation on lanes
def keccak_f1600_on_lanes(lanes: StateLanes) =
    unsafe let r = 1 :: U8 in
    let lanes_and_r = [] :! [StateLanes, U8] in
    loop 24 do
        lanes_and_r <- iota(chi(rho_and_pi(theta(lanes))), r);
        lanes <- lanes_and_r[0];
        r <- lanes_and_r[1]
    return lanes

# Keccak-f1600 permutation on state
def keccak_f1600(state: State) =
    unsafe let lanes = keccak_f1600_on_lanes(to_lanes(state)) in
    let x = 0 :: {0..4} in
    let y = 0 :: {0..4} in
    let b = 0 :: Byte in
    loop 5 do
        state <- loop 5 do
            state <- loop 8 do
                state <- state[8 * (x + 5 * y) + b => vref(store64(lanes[x][y]), b) :! U8];
                b <- (b + 1) :! Byte
            return state;
            y <- (y + 1) :! {0..4}
        return state;
        x <- (x + 1) :! {0..4}
    return state

def min(x: Nat, y: Nat): Nat = 
    if x > y then y else x

def v2b_32<$n>(vec_hash: [U8; $n]) =
    n2b(for byte in enumerate(vec_hash) fold accum = 0 :: Nat with accum + (byte[1] << (8 * (31 - byte[0]))))

# Keccak sponge function which has as a building block the Keccak-f1600 permutation
def keccak<$r, $n, $o>(bitrate: {$r * 8}, capacity: {0..1592}, input: [U8; $n], delim_suffix: U8, output_len: {$o}) =
    unsafe if !(capacity + bitrate == 1600) then fail! else
    let state = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ] :: State in
    let byterate = bitrate / 8 in
    let input_len = vlen(input) in
    let offset = 0 :: {0..$n} in
    let blk_size = 0 :: {0..$r * 8} in
    let i = 0 :: {0..199} in
    let state_and_blksize = loop $n do
        blk_size <- if offset < input_len then min(input_len - offset, byterate) :! {0..$r * 8} else blk_size;
        state <- if offset < input_len
            then loop $r * 8 do
                state <- if i < blk_size then state[i => (vref(state, i) ^ vref(input, offset + i)) :! U8] else state;
                i <- (i + 1) :! {0..199}
            return state
            else state;
        offset <- if offset < input_len then (offset + blk_size) :! {0..$n} else offset;
        state <- if offset < input_len
            then if blk_size == byterate then keccak_f1600(state) else state
            else state;
        blk_size <- if offset < input_len
            then if blk_size == byterate then 0 else blk_size
            else blk_size
    return [state, blk_size] in
    let state = state_and_blksize[0] in
    let blk_size = state_and_blksize[1] in
    let state = state[blk_size :! {0..199} => (vref(state, blk_size) ^ delim_suffix) :! U8] in
    let state = if !(delim_suffix & 128 == 0) && (blk_size == byterate - 1) then keccak_f1600(state) else state in
    let state = state[(byterate - 1) :! {0..199} => (vref(state, byterate - 1) ^ 128) :! U8] in
    let state = keccak_f1600(state) in
    let output = [] :! [U8; $o] in
    let accum = [] :! [U8; $r] in
    let i = 0 :: {0..$r} in
    loop $o do
        accum <- [] :! [U8; $r];
        blk_size <- if output_len > 0 then min(output_len, byterate) :! {0..$r} else blk_size;
        output <- if output_len > 0
            then (output ++ loop $o do
                accum <- if i < blk_size then (accum ++ [vref(state, i)]) :! [U8; $r] else accum;
                i <- (i + 1) :! {0..$r}
            return accum) :! [U8; $o]
            else output;
        output_len <- if output_len > 0 then (output_len - blk_size) :! {$o} else output_len;
    return output


## The first six of the following interfaces belong to the SHA-3 family of cryptographic hash
## algorithms as standardized by the NIST on August 5, 2015.

# Extendable output function (XOF) with 128 bits of security
def shake128<$n, $o>(input: [U8; $n], output_len: {$o}) =
    keccak(1344, 256, input, 31, output_len)

# Extendable output function (XOF) with 256 bits of security
def shake256<$n, $o>(input: [U8; $n], output_len: {$o}) =
    keccak(1088, 512, input, 31, output_len)

# 28-byte output SHA-3 hashing function
def sha3_224<$n>(input: [U8; $n]) =
    keccak(1152, 448, input, 6, 28)

# 32-byte output SHA-3 hashing function
def sha3_256<$n>(input: [U8; $n]) =
    v2b_32(keccak(1088, 512, input, 6, 32))

# 48-byte output SHA-3 hashing function
def sha3_384<$n>(input: [U8; $n]) =
    keccak(832, 768, input, 6, 48)

# 64-byte output SHA-3 hashing function
def sha3_512<$n>(input: [U8; $n]) =
    keccak(576, 1024, input, 6, 64)


## The last 4 interfaces use the Keccak hashing algorithm as originally submitted to the NIST
## competition before the padding changes in 2015. Ethereum was created in 2013 and as such still
## uses this version of Keccak.

# 28-byte output Keccak hashing function
def keccak224<$n>(input: [U8; $n]) =
    keccak(1152, 448, input, 1, 28)

# 32-byte output Keccak hashing function
def keccak256<$n>(input: [U8; $n]) =
    v2b_32(keccak(1088, 512, input, 1, 32))

# 48-byte output Keccak hashing function
def keccak384<$n>(input: [U8; $n]) =
    keccak(832, 768, input, 1, 48)

# 64-byte output Keccak hashing function
def keccak512<$n>(input: [U8; $n]) =
    keccak(576, 1024, input, 1, 64)