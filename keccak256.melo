type Bit = {0..1}
type U8 = {0..255}
type U64 = {0..18446744073709551615}
type LaneVec = [U8; 8] # a lane as a vector of U8s
type LaneNat = U64 # a lane as a 64-bit Nat
type Sheet = [LaneNat; 5]
type StateLanes = [Sheet; 5]
type State = [U8; 200]


# ROtate Left 64: rotates 64-bit Nat, n, b bits to the left
def rol64(n: Nat, b: Nat) =
    (n << (b % 64) | n >> (64 - (b % 64))) & 115792089237316195423570985008687907853269984665640564039457584007913129639935

# Loads a byte vector of length 8 into a 64-bit Nat
def load64(lane_vec: LaneVec) =
    let lane_nat = 0 :: Nat in
    let ctr = 0 :: Nat in
    loop 8 do
        lane_nat <- lane_nat + (vref(lane_vec, ctr) << (ctr * 8));
        ctr <- ctr + 1
    return lane_nat

# Stores a 64-bit Nat into a byte vector of length 8
def store64(lane_nat: LaneNat) =
    unsafe let lane_vec = [] :! [Nat; 8] in
    let ctr = 0 :: Nat in
    loop 8 do
        lane_vec <- (lane_vec ++ [(lane_nat >> (ctr * 8)) % 256]) :! [Nat; 8];
        ctr <- ctr + 1
    return lane_vec

# Converts State type to StateLane type
def to_lanes(state: State) =
    unsafe let accum = [] :! StateLanes in
    let accum_inner = [] :! Sheet in
    let x = 0 :: {0..4} in
    let y = 0 :: {0..4} in
    loop 5 do
        accum_inner <- [] :! Sheet;
        accum_inner <- loop 5 do
            accum_inner <- (accum_inner ++ [load64(state[8 * (x + 5 * y)..8 * (x + 5 * y) + 8])]) :! Sheet;
            y <- (y + 1) :! {0..4}
        return accum_inner;
        accum <- (accum ++ [accum_inner]) :! StateLanes;
        x <- (x + 1) :! {0..4};
    return accum

# Creates the C sheet which is necessary for computing the D sheet
def c(lanes: StateLanes) =
    unsafe let c = [] :! Sheet in
    let x = 0 :: {0..4} in
    loop 5 do
        c <- (c ++ [for sheet in lanes[x] fold accum = 0 :: Nat with accum ^ sheet]) :! Sheet;
        x <- (x + 1) :! {0..4}
    return c

# Creates the D sheet which is necessary for computing the θ step of the Keccak permuation
def d(c: Sheet) =
    unsafe let d = [] :! Sheet in
    let x = 0 :: Nat in
    loop 5 do
        d <- (d ++ [vref(c, (x + 4) % 5) ^ rol64(vref(c, (x + 1) % 5), 1)]) :! Sheet;
        x <- x + 1
    return d

# θ step of permutation
def theta(lanes: StateLanes) =
    unsafe let c = c(lanes) in
    let d = d(c) in
    let new_lanes = [] :! StateLanes in
    let sheet = [] :! Sheet in
    let x = 0 :: {0..4} in
    let y = 0 :: {0..4} in
    loop 5 do
        new_lanes <- (new_lanes ++ loop 5 do
            sheet <- (sheet ++ [(lanes[x][y] ^ d[x])]) :! Sheet;
            y <- (y + 1) :! {0..4}
        return [sheet]) :! StateLanes;
        x <- (x + 1) :! {0..4}
    return new_lanes

---

let s = [
    255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
] in theta(to_lanes(s))