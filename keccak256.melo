type Bit = {0..1}
type U8 = {0..255}
type U64 = {0..18446744073709551615}
type LaneVec = [U8; 8] # a lane as a vector of U8s
type LaneNat = U64 # a lane as a 64-bit Nat
type Sheet = [LaneNat; 5]
type StateLanes = [Sheet; 5]
type State = [U8; 200]


# ROtate Left 64: rotates 64-bit Nat, n, b bits to the left
def rol64(n: Nat, b: Nat) =
    (n << (b % 64) | n >> (64 - (b % 64))) & 18446744073709551615

# Loads a byte vector of length 8 into a 64-bit Nat
def load64(lane_vec: LaneVec) =
    let lane_nat = 0 :: Nat in
    let ctr = 0 :: Nat in
    loop 8 do
        lane_nat <- lane_nat + (vref(lane_vec, ctr) << (ctr * 8));
        ctr <- ctr + 1
    return lane_nat

# Stores a 64-bit Nat into a byte vector of length 8
def store64(lane_nat: LaneNat) =
    unsafe let lane_vec = [] :! [Nat; 8] in
    let ctr = 0 :: Nat in
    loop 8 do
        lane_vec <- (lane_vec ++ [(lane_nat >> (ctr * 8)) % 256]) :! [Nat; 8];
        ctr <- ctr + 1
    return lane_vec

# Converts State type to StateLane type
def to_lanes(state: State) =
    unsafe let accum = [] :! StateLanes in
    let accum_inner = [] :! Sheet in
    let x = 0 :: {0..4} in
    let y = 0 :: {0..4} in
    loop 5 do
        accum_inner <- [] :! Sheet;
        accum_inner <- loop 5 do
            accum_inner <- (accum_inner ++ [load64(state[8 * (x + 5 * y)..8 * (x + 5 * y) + 8])]) :! Sheet;
            y <- (y + 1) :! {0..4}
        return accum_inner;
        accum <- (accum ++ [accum_inner]) :! StateLanes;
        x <- (x + 1) :! {0..4};
    return accum

# Creates the C sheet which is necessary for computing the D sheet
def c(lanes: StateLanes) =
    unsafe let c = [] :! Sheet in
    let x = 0 :: {0..4} in
    loop 5 do
        c <- (c ++ [for sheet in lanes[x] fold accum = 0 :: Nat with accum ^ sheet]) :! Sheet;
        x <- (x + 1) :! {0..4}
    return c

# Creates the D sheet which is necessary for computing the θ step of the Keccak permuation
def d(c: Sheet) =
    unsafe let d = [] :! Sheet in
    let x = 0 :: Nat in
    loop 5 do
        d <- (d ++ [vref(c, (x + 4) % 5) ^ rol64(vref(c, (x + 1) % 5), 1)]) :! Sheet;
        x <- x + 1
    return d

# θ step of permutation
def theta(lanes: StateLanes) =
    unsafe let c = c(lanes) in
    let d = d(c) in
    let new_lanes = [] :! StateLanes in
    let sheet = [] :! Sheet in
    let x = 0 :: {0..4} in
    let y = 0 :: {0..4} in
    loop 5 do
        new_lanes <- (new_lanes ++ loop 5 do
            sheet <- (sheet ++ [(lanes[x][y] ^ d[x])]) :! Sheet;
            y <- (y + 1) :! {0..4}
        return [sheet]) :! StateLanes;
        x <- (x + 1) :! {0..4}
    return new_lanes

# ρ and π steps of permutation
def rho_and_pi(lanes: StateLanes) =
    unsafe let x = 1 :: {0..4} in
    let y = 0 :: {0..4} in
    let temp_x = 0 :: {0..4} in
    let t = 0 :: {0..24} in
    let curr_lane = lanes[x][y] in
    let temp_lane = 0 :! LaneNat in
    loop 24 do
        temp_x <- x;
        x <- y;
        y <- ((2 * temp_x + 3 * y) % 5) :! {0..4};
        temp_lane <- curr_lane;
        curr_lane <- lanes[x][y];
        lanes <- lanes[x => lanes[x][y => [rol64(temp_lane, (t + 1) * (t + 2) / 2)] :! LaneNat]];
        t <- (t + 1) :! {0..23}
    return lanes

---

let s = [
    255, 255, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
] in rho_and_pi(theta(to_lanes(s)))